 target C {
  platform: "RP2040",
  threading: false,
  keepalive: true
}

preamble {=
  #include <hardware/gpio.h>
  #include <pico/stdlib.h>
  #define timer_hw ((timer_hw_t *)TIMER_BASE)
  #define ALARM_NUM 0
  #define ALARM_IRQ TIMER_IRQ_0
=}

main reactor {
  preamble {=

    typedef void (*virtual_timer_callback_t)(void);
 
    // Definition of linked list node 
    typedef struct node_t {
      /* Put the variables needed for linked list node here */
      // value for the timer
      uint32_t timer_value;
      *virtual_timer_callback_t callback_func;
      // next node pointer
      struct node_t * next ;
      } node_t ;

    //The linked list for timer
    static node_t* linked_list = NULL;

    // linked list operation functions
    // insert the node in the sorted linked list (linked_list) and return the sorted linked list after the insertion
    void list_insert_sorted(node_t* node){
       if(linked_list == NULL){
          node -> next = NULL;
          linked_list = node;
       }
       else{
          if(linked_list -> timer_value > node -> timer_value){
              node -> next = linked_list;
              linked_list = node;
            }     
          else{
              // node is somewhere after the head
              node_t* prev_node = linked_list;
              node_t* curr_node = linked_list->next;
              while(curr_node != NULL && curr_node -> timer_value < node -> timer_value){
                  // iterate until end of list or the current node has a greater value
                  prev_node = curr_node;
                  curr_node = curr_node -> next;
              }
              // insert node
              prev_node -> next = node;
              node -> next = curr_node;
          } 
       }
    }

    // remove the node from linked list
    void list_remove(node_t* node){
        if(linked_list != NULL){
            if(linked_list == node){
                linked_list = linked_list -> next;
            }
            else{
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list -> next;
                while(curr_node != NULL && curr_node != node){
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                if(curr_node != NULL){
                    prev_node -> next = curr_node -> next; 
                }
            }
        }
    }
    
    // return and remove the first node in the linked list
    node_t* list_remove_first(){
      node_t* head = linked_list;
      if (head != NULL) {
          linked_list = head->next;
      }
      return head;
    }


    /* You can also create your own linked list functions here. */

    static node_t* timer = NULL;

    virtual_timer_callback_t callback_func0 () {
        timer->callback_func();
        free(timer);
        self->led_on = !self->led_on;
        gpio_put(PICO_DEFAULT_LED_PIN, !self->led_on);
    }

    void lab5_timer_irq_handler(void){
        //Alarm 0 has fired
        printf("Timer Fired!");        
        //Clear the alarm irq
        hw_clear_bits(&timer_hw->intr,1u << ALARM_NUM);
    }

    void virtual_timer_init(void){
        //Enable the interrupt for our alarm
        hw_set_bits(timer_hw->inte,1u << ALARM_NUM);
        //Set irq handler for alarm irq
        irq_set_exclusive_handler(ALARM_IRQ,lab5_timer_irq_handler);
        //Enable the alarm irq 
        irq_set_enabled(ALARM_IRQ,true); 
    }

    uint32_t virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb){
        virtual_timer_init();
        imer_hw->alarm[ALARM_NUM] = timer_hw->timerawl + microseconds;

        // node_t* timer = malloc(sizeof(node_t));
        // timer->timer_value = timer_hw->timerawl + microseconds;
        // timer->callback_func = *callback_func0();
        // list_insert_sorted(timer);
        // return ALARM_NUM;
    }


    uint32_t virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb){
        /* TODO */
    }
    void virtual_timer_cancel(uint32_t time_id ){
        while(timer->timer_value != time_id )
        {timer->next = timer;}
        list_remove(timer->next);
        timer_hw->alarm[ALARM_NUM] = 0;
    }

  =}


  timer print_hw_timer(0, 1000ms)
//   state get_time: uint64_t = 0;
  state led_on:bool = false;

  reaction(startup) {=
      // initialize the LED and the virtual timer    
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
      gpio_put(25, true);
      virtual_timer_init();
  =}
  
  reaction(print_hw_timer){=
    //   uint32_t low = timer_hw->timelr;
    //   uint32_t high = timer_hw->timehr;
    //   self-> get_time = (timer_hw->timehr << 32u) | timer_hw->timelr;
      printf("Read timer value: %9d us.\n",timer_hw->timelr);
  =}

  reaction(virtual_timer_start(2000)){=
      lab5_timer_irq_handler();
  =}


  /* TODO: add reaction and timer to create the environment to test */
  
}
