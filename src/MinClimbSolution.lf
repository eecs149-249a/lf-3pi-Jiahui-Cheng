target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
import Motors from "lib/Motors.lf"
import Line from "lib/Line.lf"
import Display from "lib/Display.lf"
import GyroAngle from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"
import AngleToDistance from "lib/AngleToDistance.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import PIControl from "lib/MotorsWithFeedback.lf"
import Tilt from "lib/Tilt.lf"
import Accelerometer from "lib/IMU.lf"

main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
  motor = new Motors()
  line = new Line()
  disp = new Display()
  gyroangle = new GyroAngle()
  encoder = new Encoders()
  accelerometer = new Accelerometer()
  tilt = new Tilt()
  angletodistL = new AngleToDistance()
  angletodistR = new AngleToDistance()
  motorfeedback = new MotorsWithFeedback()
  rollfeedback = new PIControl()

  timer t(0, sample_period)
  timer t2(0, 250 ms)
  timer end_calibration(calibration_time)
  state rel_0_angle:float = 0;
  state K:float = 1;

//Line Sensor Calibration
  reaction(startup) -> disp.line3 {=
    lf_set(disp.line3, "CALIBRATING");
  =}
// Line Sensor Trigger
  reaction(t) -> line.trigger {=
  lf_set(line.trigger, true);
  =}

// Encoder Distance Readings
  reaction(t2) -> encoder.trigger, gyroangle.trigger,accelerometer.trigger{=
    lf_set(encoder.trigger, true);
    lf_set(gyroangle.trigger,true);
    lf_set(accelerometer.trigger, true);
    =}
  reaction(encoder.left) ->  angletodistL.encoder_reading, motorfeedback.left {=
    lf_set(angletodistL.encoder_reading, encoder.left->value); //Input to AngleToDist
    lf_set(motorfeedback.left, encoder.left->value); //Input to Motors with Feedback
  =}
  reaction(encoder.right) ->  angletodistR.encoder_reading, motorfeedback.right {=
    lf_set(angletodistR.encoder_reading, encoder.right->value); //Input to AngleToDist
    lf_set(motorfeedback.right, encoder.right->value); //Input to Motors with Feedback
  =}
  reaction(accelerometer.x, accelerometer.y, accelerometer.z) ->  tilt.x, tilt.y, tilt.z {=
    // static float bx = -0.018;
    // static float by = -0.0275;
    // static float bz = 0.0;
    // static float mz = 1.0;
    // static float my = 0.987 + 0.0275;
    // static float mx = 0.998;
    lf_set(tilt.x, accelerometer.x->value);
    lf_set(tilt.y, accelerometer.y->value);
    lf_set(tilt.z, accelerometer.z->value);
  =}
  reaction(tilt.pitch, tilt.roll) -> disp.line0, disp.line1 {=
    static char buf0[17];
    static char buf1[17];
    snprintf(buf0, 17, "pitch:%3.3f", tilt.pitch->value);
    snprintf(buf1, 17, "roll:%3.3f", tilt.roll->value);
    lf_set(disp.line0, buf0);
    lf_set(disp.line1, buf1);
  =}

  reaction(tilt.roll) -> rollfeedback.err {=
    lf_set(rollfeedback.err, 0.0f-tilt.roll->value); // output is rollfeedback.ctrl
  =}

  initial mode Calibrating {
    reaction(end_calibration) -> OrientingUp, motor.left_power, motor.right_power,line.calibrate, disp.line3 {=
      lf_set(line.calibrate, false);
      lf_set(motor.left_power,-0.1f);
      lf_set(motor.right_power,0.1f);
      lf_set(disp.line3, "Orienting Up");
      lf_set_mode(OrientingUp);
    =}
  }
  
  mode OrientingUp {
    reaction(tilt.pitch, tilt.roll) -> DrivingUp, motor.left_power, motor.right_power, disp.line3 {=
      if (tilt.pitch->value > 0.0f && abs(tilt.roll->value) < 4.0f) {
        lf_set(disp.line3, "Driving Up");
        lf_set_mode(DrivingUp);
      }
      else {
        lf_set(motor.left_power,-0.12f);
        lf_set(motor.right_power,0.12f);
      }
    =}
  }


  mode DrivingUp {
    reaction(tilt.pitch) gyroangle.z -> TurnAround, motor.left_power, motor.right_power, disp.line3 {=
      // lf_set(motor.left_power, 0.15f);
      // lf_set(motor.right_power, 0.15f);
      if (tilt.pitch->value < 1.0f) {
        lf_set(disp.line3, "TurnAround");
        self->rel_0_angle = gyroangle.z->value;
        lf_set_mode(TurnAround);
      }
    =}
    
    reaction(rollfeedback.ctrl) -> motorfeedback.left_speed, motorfeedback.right_speed {=
      if (rollfeedback.ctrl ->value > 1.6f) {
        self->K = 1.6f;
      }
      else if (rollfeedback.ctrl->value < 0) {
        self->K = 0.0f;
      }
      lf_set(motorfeedback.left_speed, K->value/8.0f);
      lf_set(motorfeedback.right_speed, 1.0f/8.0f);
    =}
  }


  mode TurnAround {
    reaction(gyroangle.z) ->  DrivingDown, motorfeedback.left_speed, motorfeedback.right_speed, disp.line2, disp.line3{=
      static char buf2[17];
      snprintf(buf2, 17, "yaw angle:%3.3f", gyroangle.z->value - self->rel_0_angle);
      lf_set(disp.line2, buf2);
      // lf_set(motor.left_power, -0.07f); 
      // lf_set(motor.right_power, 0.07f);
      lf_set(motorfeedback.left_speed, -0.01f);
      lf_set(motorfeedback.right_speed, 0.01f);
      if (abs(gyroangle.z->value - self->rel_0_angle) >= 180.0f) {
        lf_set(disp.line3, "DrivingDown");
        lf_set_mode(DrivingDown);
      }
    =}
  }

  mode DrivingDown {
    // reaction(tilt.pitch) -> motor.left_power, motor.right_power {=
      // lf_set(motor.left_power, 0.1f);
      // lf_set(motor.right_power, 0.1f);
    reaction(rollfeedback.ctrl) -> motorfeedback.left_speed, motorfeedback.right_speed {=
      if (rollfeedback.ctrl ->value > 1.6f) {
        self->K = 1.6f;
      }
      else if (rollfeedback.ctrl ->value < 0) {
        self->K = 0.0f;
      }
      lf_set(motorfeedback.left_speed, K->value/10.0f);
      lf_set(motorfeedback.right_speed, (1.0f/10.0f));
    =}
    }
        
    // reaction(tilt.pitch) -> motor.left_power, motor.right_power, disp.line3 {=
    //   if (tilt.pitch->value < 0.005f) {
    //     lf_set(motor.left_power, 0.0f);
    //     lf_set(motor.right_power, 0.0f);
    //     lf_set(disp.line3, "Complete!");
    //   }
      
    // =}
}
  
  
