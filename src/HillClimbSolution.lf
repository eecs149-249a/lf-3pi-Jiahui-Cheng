target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Motors from "lib/Motors.lf"
  import Line from "lib/Line.lf"
  import Display from "lib/Display.lf"
  import GyroAngle from "lib/IMU.lf"
  import Encoders from "lib/Encoders.lf"
  import AngleToDistance from "lib/AngleToDistance.lf"
  import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
  import Tilt from "lib/Tilt.lf"
  
  main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
    motor = new Motors()
    line = new Line()
    disp = new Display()
    gyroangle = new GyroAngle()
    encoder = new Encoders()
    accelerometer = new Accelerometer()
    tilt = new Tilt()
    angletodistL = new AngleToDistance()
    angletodistR = new AngleToDistance()
    feedback = new MotorsWithFeedback()
  
    timer t(0, sample_period)
    timer seconds(0, 1 s)
    timer end_calibration(calibration_time)
    
    state drive:bool = false
    state turn:bool = false

    timer t2(0, 250 ms)
    state total_dist:float = 0;
    state rel_0_dist:float = 0;
    state rel_0_angle:float = 0;
    state rel_0_pitch:float = 0;
    state rel_0_roll:float = 0;

// Line Sensor Calibration
    reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
      lf_set(disp.line0, "CALIBRATING");
      lf_set(disp.line1, "Roll robot over");
      lf_set(disp.line2, "light and dark.");
      
    =}
    reaction(end_calibration) -> line.calibrate {=
        lf_set(line.calibrate, false);
    =}
// Line Sensor Trigger
    reaction(t) -> line.trigger {=
    lf_set(line.trigger, true);
    =}

// Encoder Distance Readings
    reaction(t2) -> encoder.trigger, gyroangle.trigger,accelerometer.trigger {=
        lf_set(encoder.trigger, true);
        lf_set(gyroangle.trigger,true);
        lf_set(accelerometer.trigger, true);
      =}
    reaction(encoder.left) ->  angletodistL.encoder_reading, feedback.left {=
        lf_set(angletodistL.encoder_reading, encoder.left->value); //Input to AngleToDist
        lf_set(feedback.left, encoder.left->value); //Input to Motors with Feedback
    =}
    reaction(encoder.right) ->  angletodistR.encoder_reading, feedback.right {=
        lf_set(angletodistR.encoder_reading, encoder.right->value); //Input to AngleToDist
        lf_set(feedback.right, encoder.right->value); //Input to Motors with Feedback
    =}
    reaction(accelerometer.x, accelerometer.y, accelerometer.z) ->  tilt.x, tilt.y, tilt.z {=

        static float bx = -0.018;
        static float by = -0.0275;
        static float bz = 0.0;

        static float mz = 1.0;
        static float my = 0.987 + 0.0275;
        static float mx = 0.998;
        
        lf_set(tilt.x, (accelerometer.x->value - bx) / mx);
        lf_set(tilt.y, (accelerometer.y->value - by) / my);
        lf_set(tilt.z, (accelerometer.z->value - bz) / mz);

    =}

    initial mode Calibrating {
        reaction(end_calibration) tilt.pitch,tilt.roll -> Navigation, motor.left_power, motor.right_power,disp.line3 {=
            lf_set(disp.line3, "Navigation");
            if (tilt.pitch < 0 && tilt.roll != 0){
 //If at right egde, turn left, vice versa
               lf_set(motor.left_power, 0); 
               lf_set(motor.right_power, 0.1f);
             }
            else {
               self->rel_0_pitch = tilt.pitch->value;
               lf_set_mode(Navigation);
            }
          =}
    }
    mode Navigation {
      reaction(tilt.roll) -> DrivingUp, motor.left_power, motor.right_power,disp.line3 {=

            lf_set(disp.line3, "DrivingUp");
            
            lf_set(feedback.left_speed, 0.05f);
            lf_set(feedback.right_speed, 0.05f);
            lf_set(motor.left_power, feedback.control_left.ctrl);
            lf_set(motor.right_power, feedback.control_left.ctrl);

            lf_set_mode(DrivingUp);
         =}
    }


    mode DrivingUp {
        reaction(tilt.pitch) -> TurnAround, motor.left_power, motor.right_power,disp.line3 {=
          if (tilt.pitch->value - self->rel_0_pitch>= -20) {
            self->rel_0_pitch = tilt.pitch->value;
            lf_set(disp.line3, "TurnAround");
 //If at right egde, turn left, vice versa
            lf_set(motor.left_power, 0); 
            lf_set(motor.right_power, 0.1f);
            lf_set_mode(TurnAround);
            }
          =}
    }


    mode TurnAround {
        reaction(gyroangle.z) ->  Drivingdown, motor.left_power, motor.right_power, disp.line3{=
            if (gyroangle.z->value - self->rel_0_angle>= 180) {
                self->rel_0_angle = gyroangle.z->value;

                lf_set(disp.line3, "DrivingDown");
                lf_set(feedback.left_speed, 0.03f);
                lf_set(feedback.right_speed, 0.03f);
                lf_set(motor.left_power, feedback.control_left.ctrl);
                lf_set(motor.right_power, feedback.control_left.ctrl);
                lf_set_mode(DrivingDown);
            }
        =}
    }

    mode DrivingDown {
      reaction(tilt.roll) -> DrivingUp, motor.left_power, motor.right_power,disp.line3 {=

            lf_set(disp.line3, "DrivingUp");
            
            lf_set(feedback.left_speed, 0.05f);
            lf_set(feedback.right_speed, 0.05f);
            lf_set(motor.left_power, feedback.control_left.ctrl);
            lf_set(motor.right_power, feedback.control_left.ctrl);

            lf_set_mode(DrivingUp);
         =}
    }
  

}
  
  
