target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Motors from "lib/Motors.lf"
  import Line from "lib/Line.lf"
  import Display from "lib/Display.lf"
  import GyroAngle from "lib/IMU.lf"
  import Encoders from "lib/Encoders.lf"
  import AngleToDistance from "lib/AngleToDistance.lf"
  import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
  
  main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
    motor = new Motors()
    line = new Line()
    disp = new Display()
    gyroangle = new GyroAngle()
    encoder = new Encoders()
    angletodistL = new AngleToDistance()
    angletodistR = new AngleToDistance()
    feedback = new MotorsWithFeedback()
  
    timer t(0, sample_period)
    timer seconds(0, 1 s)
    timer end_calibration(calibration_time)
    state count: int = 0
    state drive:bool = false
    state turn:bool = false

    timer t2(0, 250 ms)
    state total_dist:float = 0;
    state rel_0_dist:float = 0;
    state rel_0_angle:float = 0;

// Line Sensor Calibration
    reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
      lf_set(disp.line0, "CALIBRATING");
      lf_set(disp.line1, "Roll robot over");
      lf_set(disp.line2, "light and dark.");
      
    =}
    reaction(end_calibration) -> line.calibrate {=
        lf_set(line.calibrate, false);
    =}
// Line Sensor Trigger
    reaction(t) -> line.trigger {=
    lf_set(line.trigger, true);
    =}

// Encoder Distance Readings
    reaction(t2) -> encoder.trigger, gyroangle.trigger {=
        lf_set(encoder.trigger, true);
        lf_set(gyroangle.trigger,true);
      =}
    reaction(encoder.left) ->  angletodistL.encoder_reading, feedback.left {=
        lf_set(angletodistL.encoder_reading, encoder.left->value); //Input to AngleToDist
        lf_set(feedback.left, encoder.left->value); //Input to Motors with Feedback
    =}
    reaction(encoder.right) ->  angletodistR.encoder_reading, feedback.right {=
        lf_set(angletodistR.encoder_reading, encoder.right->value); //Input to AngleToDist
        lf_set(feedback.right, encoder.right->value); //Input to Motors with Feedback
    =}

    initial mode Calibrating {
        reaction(end_calibration) -> DrivingUp, motor.left_power, motor.right_power,disp.line3 {=
            lf_set(disp.line3, "DrivingUp");
            // Driving Up -- Desired Speeds
            lf_set(feedback.left_speed, 0.05f);
            lf_set(feedback.right_speed, 0.05f);
            lf_set(motor.left_power, feedback.control_left.ctrl); // set motor power to output of PI controller
            lf_set(motor.right_power, feedback.control_left.ctrl);
            lf_set_mode(DrivingUp);
          =}
    }
      
    mode DrivingUp {
        reaction(line.reflect) -> LeftAvoid, RightAvoid, CenterAvoid, motor.left_power, motor.right_power, disp.line0, disp.line1, disp.line2, disp.line3 {=

            if (line.reflect -> value[0] > 700 || line.reflect -> value[1] > 700) {
              lf_set(disp.line0, "Left: Avoid!");
              lf_set(motor.left_power,-0.1f);
              lf_set(motor.right_power, -0.1f);
              lf_set_mode(LeftAvoid);
            }
            else {
              lf_set(disp.line0, "Left: Clear");
            }
            if (line.reflect -> value[3] > 700 || line.reflect -> value[4] > 700) {
              lf_set(disp.line2, "Right: Avoid!");
              lf_set(motor.left_power,-0.1f);
              lf_set(motor.right_power, -0.1f);
              lf_set_mode(RightAvoid);
            }
            else {
              lf_set(disp.line2, "Right: Clear");
            }
            if (line.reflect -> value[1] > 700 || line.reflect -> value[2] > 700 || line.reflect -> value[3] >700)  {
              lf_set(disp.line1,"Center: Avoid!");
              lf_set(motor.left_power,-0.1f);
              lf_set(motor.right_power, -0.1f);
              lf_set_mode(CenterAvoid);
            }
            else {
              lf_set(disp.line1, "Center: Clear");
            }
            if (gyro.y <= 0) { //pitch less than 0
              lf_set(disp.line3,"Reached Plateau");
              lf_set(motor.left_power,-0.1f);
              lf_set(motor.right_power, 0.1f);
              lf_set_mode(TurnAround);

            }
          =}
    }

    mode LeftAvoid {
        reaction(angletodistL.encoder_dist_cm, angletodistR.encoder_dist_cm)  -> TurnRight, motor.left_power, motor.right_power, disp.line3 {=
            self-> total_dist = (angletodistL.encoder_dist_cm->value+angletodistR.encoder_dist_cm->value)/2;
            if(self->total_dist - self->rel_0_dist <= -2.0) {
               self->rel_0_dist = self->total_dist;
               lf_set(disp.line3, "TurnRight");
               lf_set(motor.left_power, 0.1f);
               lf_set(motor.right_power, -0.1f);
               lf_set_mode(TurnRight);
            }
    =}
    }

    mode RightAvoid {
        reaction(angletodistL.encoder_dist_cm, angletodistR.encoder_dist_cm)  -> TurnLeft, motor.left_power, motor.right_power, disp.line3 {=
            self-> total_dist = (angletodistL.encoder_dist_cm->value+angletodistR.encoder_dist_cm->value)/2;
            if(self->total_dist - self->rel_0_dist <= -2.0) {
               self->rel_0_dist = self->total_dist;
               lf_set(disp.line3, "TurnLeft");
               lf_set(motor.left_power, -0.1f);
               lf_set(motor.right_power, 0.1f);
               lf_set_mode(TurnLeft);
            }
    =}
    }

    mode CenterAvoid {
        reaction(angletodistL.encoder_dist_cm, angletodistR.encoder_dist_cm)  -> TurnAround, motor.left_power, motor.right_power, disp.line3 {=
            self-> total_dist = (angletodistL.encoder_dist_cm->value+angletodistR.encoder_dist_cm->value)/2;
            if(self->total_dist - self->rel_0_dist <= -2.0) {
               self->rel_0_dist = self->total_dist;
               lf_set(disp.line3, "TurnAround");
               lf_set(motor.left_power, -0.1f);
               lf_set(motor.right_power, 0.1f);
               lf_set_mode(TurnAround);
            }
        =}
    }

    mode TurnRight {
      reaction(gyroangle.z) ->  DrivingUp, motor.left_power, motor.right_power, disp.line0, disp.line3{=
        if (gyroangle.z->value - self->rel_0_angle>= -90) {
            self->rel_0_angle = gyroangle.z->value;
            lf_set(disp.line3, "DrivingUp");
            lf_set(motor.left_power, 0.1f);
            lf_set(motor.right_power, 0.1f);
            lf_set_mode(DrivingUp);
        }

    =}
    }

    mode TurnLeft {
        reaction(gyroangle.z) ->  DrivingUp, motor.left_power, motor.right_power, disp.line3{=
            if (gyroangle.z->value - self->rel_0_angle>= 90) {
                self->rel_0_angle = gyroangle.z->value;
                lf_set(disp.line3, "DrivingUp");
                lf_set(motor.left_power, 0.1f);
                lf_set(motor.right_power, 0.1f);
                lf_set_mode(DrivingUp);
            }
        =}
    }

    mode TurnAround {
        reaction(gyroangle.z) ->  DrivingUp, motor.left_power, motor.right_power, disp.line3{=
            if (gyroangle.z->value - self->rel_0_angle>= 180) {
                self->rel_0_angle = gyroangle.z->value;
                lf_set(disp.line3, "DrivingDown");
                lf_set(motor.left_power, 0.1f);
                lf_set(motor.right_power, 0.1f);
                lf_set_mode(DrivingDown);
            }
        =}
    }
}
  
  