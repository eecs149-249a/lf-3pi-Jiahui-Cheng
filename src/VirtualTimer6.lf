target C {
    platform: "RP2040",
    threading: false,
    keepalive: true
  }
  
  preamble {=
    #include <hardware/gpio.h>
    #include <pico/stdlib.h>
    #define timer_hw ((timer_hw_t *)TIMER_BASE)
    #define ALARM_NUM 0
    #define ALARM_IRQ TIMER_IRQ_0
  =}
  
  main reactor {
    preamble {=
  
      typedef void (*virtual_timer_callback_t)(void);
   
      // Definition of linked list node 
       typedef struct node_t {
  
        // value for the timer
        uint32_t timer_value;
        // callback_function pointer
        virtual_timer_callback_t callback;
        // TimerID
        bool repeat;
        // time interval
        uint32_t timer_interval;
        // next node pointer
        struct node_t * next;

        } node_t ;
  
      //The linked list for timer
      static node_t* linked_list = NULL;
      static bool led_on = false;

      static int repeat_time = 0;
      static int target_time;
  
      // linked list operation functions
      // insert the node in the sorted linked list (linked_list) and return the sorted linked list after the insertion
      void list_insert_sorted(node_t* node){
         if(linked_list == NULL){
            node -> next = NULL;
            linked_list = node;
         }
         else{
            if(linked_list -> timer_value > node -> timer_value){
                node -> next = linked_list;
                linked_list = node;
              }     
            else{
                // node is somewhere after the head
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list->next;
                while(curr_node != NULL && curr_node -> timer_value < node -> timer_value){
                    // iterate until end of list or the current node has a greater value
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                // insert node
                prev_node -> next = node;
                node -> next = curr_node;
            } 
         }
      }
  
      // remove the node from linked list
      void list_remove(node_t* node){
          if(linked_list != NULL){
              if(linked_list == node){
                  linked_list = linked_list -> next;
              }
              else{
                  node_t* prev_node = linked_list;
                  node_t* curr_node = linked_list -> next;
                  while(curr_node != NULL && curr_node != node){
                      prev_node = curr_node;
                      curr_node = curr_node -> next;
                  }
                  if(curr_node != NULL){
                      prev_node -> next = curr_node -> next; 
                  }
              }
          }
      }
      
      // return and remove the first node in the linked list
        node_t* list_remove_first(){
        node_t* head = linked_list;
        if (head != NULL) {
            linked_list = head->next;
        }
        return head;
      }
  
  
      /* You can also create your own linked list functions here. */
  
      virtual_timer_callback_t callback_function () {
          printf("Toggle LED!");
          node_t* current = list_remove_first();

          if (current->repeat){
            current-> timer_value = timer_hw->timerawl + current-> timer_interval;
            list_insert_sorted(current);   
            self->led_on = !self->led_on;
            gpio_put(PICO_DEFAULT_LED_PIN, !self->led_on);

            repeat_time ++;
            printf("Repeat time: %d",repeat_time);
            if (repeat_time >= target_time) {
              virtual_timer_cancel(virtual_timer_start_repeated(1000000*1,callback_function()));
            }
          }
          else {
            free(current);
          }
                
      }
  
      void lab5_timer_irq_handler(void){ 
          linked_list -> callback;
          //Clear the alarm irq
          hw_clear_bits(&timer_hw->intr,1u << ALARM_NUM);
          if (linked_list != NULL) {
             timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;
          }
          
      }
  
      void virtual_timer_init(void){
  
          //Enable the interrupt for our alarm
          hw_set_bits(&timer_hw->inte,1u << ALARM_NUM);
          //Set irq handler for alarm irq
          irq_set_exclusive_handler(ALARM_IRQ,lab5_timer_irq_handler);
          //Enable the alarm irq 
          irq_set_enabled(ALARM_IRQ,true); 
  
      }
  
      uint32_t virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb){
  
          node_t* timer = malloc(sizeof(node_t));
          timer->timer_value = timer_hw->timerawl + microseconds;
          timer->callback = &cb;
          timer->timer_interval = 0;
          timer->repeat = false;   
          list_insert_sorted(timer);
          timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;
  
        //   int TimerID = 1;
        //   node_t * current = linked_list;
        //   while (current->timer_value != timer->timer_value) {
        //   current = current->next;
        //   TimerID ++;
        //   }
        //   return TimerID;
          return timer->timer_value;
      }
  
  
      uint32_t virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb){
          node_t* timer = malloc(sizeof(node_t));
          timer->timer_value = timer_hw->timerawl + microseconds;
          timer->timer_interval = microseconds;
          timer->repeat = true;
          timer->callback = &cb;
          list_insert_sorted(timer);

          timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;

          return timer->timer_interval;
      }

      void virtual_timer_cancel(uint32_t time_id ){
        node_t * current = linked_list;
        while (current->timer_interval != time_id) {
        current = current->next;
        }
        free(list_remove(current));
        timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;
      }
  
    =}
  
  
    reaction(startup) {=
        // initialize the LED and the virtual timer    
        gpio_init(PICO_DEFAULT_LED_PIN);
        gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
        gpio_put(25, true);
  
        virtual_timer_init();
        virtual_timer_start_repeated(1000000*1,callback_function());
        target_time = 5;
    =}
  
    // timer t (5s,0);
    // reaction(t) {=
    //     virtual_timer_cancel(virtual_timer_start_repeated(1000000*1,callback_function()));
    // =}

  }
  