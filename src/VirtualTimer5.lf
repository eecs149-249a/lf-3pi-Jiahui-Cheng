target C {
    platform: "RP2040",
    threading: false,
    keepalive: true
  }
  
  preamble {=
    #include <hardware/gpio.h>
    #include <pico/stdlib.h>
    #define timer_hw ((timer_hw_t *)TIMER_BASE)
    #define ALARM_NUM 0
    #define ALARM_IRQ TIMER_IRQ_0
  =}
  
  main reactor {
    preamble {=
  
      typedef void (*virtual_timer_callback_t)(void);
   
      // Definition of linked list node 
       typedef struct node_t {
  
        uint32_t timer_value;
        virtual_timer_callback_t callback;
        bool repeat;
        uint32_t timer_interval;
        struct node_t * next;
        } node_t ;
  
      //The linked list for timer
      static node_t* linked_list = NULL;
      static bool led_on = false;
  
      // linked list operation functions
      // insert the node in the sorted linked list (linked_list) and return the sorted linked list after the insertion
      void list_insert_sorted(node_t* node){
         if(linked_list == NULL){
            node -> next = NULL;
            linked_list = node;
         }
         else{
            if(linked_list -> timer_value > node -> timer_value){
                node -> next = linked_list;
                linked_list = node;
              }     
            else{
                // node is somewhere after the head
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list->next;
                while(curr_node != NULL && curr_node -> timer_value < node -> timer_value){
                    // iterate until end of list or the current node has a greater value
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                // insert node
                prev_node -> next = node;
                node -> next = curr_node;
            } 
         }
      }
  
      // remove the node from linked list
      void list_remove(node_t* node){
          if(linked_list != NULL){
              if(linked_list == node){
                  linked_list = linked_list -> next;
              }
              else{
                  node_t* prev_node = linked_list;
                  node_t* curr_node = linked_list -> next;
                  while(curr_node != NULL && curr_node != node){
                      prev_node = curr_node;
                      curr_node = curr_node -> next;
                  }
                  if(curr_node != NULL){
                      prev_node -> next = curr_node -> next; 
                  }
              }
          }
      }
      
      // return and remove the first node in the linked list
        node_t* list_remove_first(){
        node_t* head = linked_list;
        if (head != NULL) {
            linked_list = head->next;
        }
        return head;
      }
  
  
      /* You can also create your own linked list functions here. */
  
      virtual_timer_callback_t callback_function_repeated () {
            led_on = !led_on;
            gpio_put(PICO_DEFAULT_LED_PIN, !led_on);          
      }
  
      void lab5_timer_irq_handler(void){
            linked_list -> callback(); 


        if (linked_list->repeat == true){
            linked_list-> timer_value = timer_hw->timerawl + linked_list-> timer_interval;
            list_insert_sorted(list_remove_first());  
          }
          else {
            free(list_remove_first());
          }
          
          //Clear the alarm irq
          hw_clear_bits(&timer_hw->intr,1u << ALARM_NUM);
          if (linked_list != NULL) {
             timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;
          }
          
      }
  
      void virtual_timer_init(void){
  
          //Enable the interrupt for our alarm
          hw_set_bits(&timer_hw->inte,1u << ALARM_NUM);
          //Set irq handler for alarm irq
          irq_set_exclusive_handler(ALARM_IRQ,lab5_timer_irq_handler);
          //Enable the alarm irq 
          irq_set_enabled(ALARM_IRQ,true); 
  
      }
  
    uint32_t virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb){
    
        node_t* timer = malloc(sizeof(node_t));
        timer->timer_value = timer_hw->timerawl + microseconds;
        timer->timer_interval = 0;
        timer->repeat = false;        
        timer->callback = cb;
        list_insert_sorted(timer);
        timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;
        return timer->timer_value;
    }


    uint32_t virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb){
    node_t* timer = malloc(sizeof(node_t));
    timer->timer_value = timer_hw->timerawl + microseconds;
    timer->timer_interval = microseconds;
    timer->repeat = true;
    timer->callback = cb;
    list_insert_sorted(timer);

    timer_hw->alarm[ALARM_NUM] = linked_list -> timer_value;

    return timer->timer_value;
    }

      void virtual_timer_cancel(uint32_t time_id ){
        // list_remove(node_t* node);
      }
  
    =}
  
  
    reaction(startup) {=
        // initialize the LED and the virtual timer    
        gpio_init(PICO_DEFAULT_LED_PIN);
        gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
        gpio_put(25, true);
  
        virtual_timer_init();
        virtual_timer_start_repeated(1000000*1,callback_function_repeated);
    =}
  
    
  }
  