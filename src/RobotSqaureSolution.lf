/**
 * Template for robot driving lab exercises.
 * This template just periodically switches between a
 * STOPPED and a DRIVING mode, updating the LCD display
 * on each change of mode.
 */
target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import GyroAngle from "lib/IMU.lf"
import AngleToDistance from "lib/AngleToDistance.lf"

reactor Robot {
   
  input drive:bool       // Toggle mode.
  output notify:string   // Notify of mode change.
  motors = new Motors()


  reaction(startup) -> notify {=
    lf_set(notify, "INIT");
  =}

  initial mode TURNING {
    reaction(drive) -> DRIVING, notify, motors.left_power, motors.right_power {=
      if (drive->value) {
        // motors.left_power->value = 0;
        // motors.right_power->value = 0;
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.1f);
        lf_set_mode(DRIVING);
        lf_set(notify, "DRIVING");
      }
    =}
  }

  mode DRIVING {
    reaction(drive) -> TURNING, notify, motors.left_power, motors.right_power {=
      if (!drive->value) {
        // motors.left_power->value = 0.1f;
        // motors.right_power->value = 0.1f;
        lf_set(motors.left_power, 0);
        lf_set(motors.right_power, 0.1f);
        lf_set_mode(TURNING);
        lf_set(notify, "TURNING");
      }
    =}
  }
}

main reactor {
  //timer t(0, 2 sec)
  state drive:bool = true
  robot = new Robot()
  display = new Display()
  gyro_angle = new GyroAngle()
  angle_to_dis = new AngleToDistance()

  state pre_angle:float = 0
  state pre_left:float = 0
  state pre_right:float = 0

  reaction(startup){=
    self->drive = !self->drive ;
  =}

  

  reaction(gyro_angle.z, angle_to_dis.distance1, angle_to_dis.distance2) -> robot.drive {=
      if (self->drive == false && gyro_angle.z->value - self->pre_angle >= 90.0)
      {
        lf_set(robot.drive, self->drive);
        self->drive = true;
        self->pre_angle = gyro_angle.z->value;
      }

      if (self->drive == true && angle_to_dis.distance1->value - self->pre_left >= 1 && angle_to_dis.distance2->value - self->pre_right>=1)
        {
          lf_set(robot.drive, self->drive);
          self->drive = false;
          self->pre_left = angle_to_dis.distance1->value;
          self->pre_right = angle_to_dis.distance2->value;
        }
  =}
  robot.notify -> display.line0;

//   reaction(motors.left_power, motors.right_power) -> d.line1,d.line2{=
//     /// TODO: define max string size for line
//     /// based on font you can have 4 or 8 lines 
//     static char buf1[17];
//     static char buf2[17];

//     snprintf(buf1, 17, "x:%2.4f", robot.motors.left_power);
//     snprintf(buf2, 17, "y:%2.4f", robot.motors.right_powerpower));
    
//     lf_set(d.line1, buf1);
//     lf_set(d.line2, buf2);
// =}

}
